// import * as anchor from "@coral-xyz/anchor";
// import { Program, web3, BN } from "@coral-xyz/anchor";
// import { Keypair, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
// import { ShuihuDapp } from "../target/types/shuihu_dapp";
// import chalk from "chalk";
// // import testSecretKey from "../test_keypair.json";
// import { OraoVrfTestHelper } from "./orao_vrf_utils.local";
// import { assert } from "chai";
// import { createUmi } from "@metaplex-foundation/umi-bundle-defaults";
// import { hero_list } from "./heroData";
// import {
//   getAssociatedTokenAddressSync,
//   TOKEN_2022_PROGRAM_ID,
// } from "@solana/spl-token";
// import {
//   fetchAssetsByOwner,
//   fetchAsset,
//   fetchCollection,
//   fetchAllAssets,
//   fetchAssetV1,
//   mplCore,
// } from "@metaplex-foundation/mpl-core";
// import { bs58 } from "@coral-xyz/anchor/dist/cjs/utils/bytes";

// // import { user } from "@nextui-org/theme";

// const log = console.log;
// const group = console.group;
// const groupEnd = console.groupEnd;

// // Seed
// const TOKEN_MINT = Buffer.from("TOKEN_MINT");
// const SHUIHU_SEED = Buffer.from("SHUIHU");
// const MINT_STATE_SEED = Buffer.from("SHUIHU_HERO_MINT_STATE");
// const USER_COLLECTION_SEED = Buffer.from("USER_COLLECTION");
// const ROUND_CLAIM_SEED = Buffer.from("ROUND_CLAIM");
// const START_MINT_PRICE = 10_000_000;
// const START_ROUND = 1;

// // const HERO_COL_NAME = "Shuihu Hero Collection"; // Ëã±ÈõÑÈõÜÂêàÂêçÁß∞

// describe("shuihu_dapp", () => {
//   const provider = anchor.AnchorProvider.env();
//   let vrfTestHelper: OraoVrfTestHelper;
//   anchor.setProvider(provider);

//   const umi = createUmi(provider.connection.rpcEndpoint, "processed").use(
//     mplCore()
//   );
//   // const umi = createUmi(provider.connection.rpcEndpoint);
//   // const umi = createUmi(provider.connection.rpcEndpoint).use(dasApi());

//   const wallet = provider.wallet as anchor.Wallet;
//   const team = new PublicKey("tesSimU5mgfeXXDYUXCWcL3q6BGVxMEpArYRn5VbTdN");
//   const program = anchor.workspace.ShuihuDapp as Program<ShuihuDapp>;
//   const heroCollection = Keypair.generate();
//   const testUser = Keypair.generate();
//   const testUser2 = Keypair.generate();
//   const wrongMintUser = Keypair.generate();
//   const wrongCollectUser = Keypair.generate();
//   const wrongCombineUser = Keypair.generate();
//   const claimer1 = Keypair.generate();
//   const claimer2 = Keypair.generate();

//   const frontUser = Keypair.fromSecretKey(
//     bs58.decode(
//       "4VCdUyqXTViGFum76b5C4vwfhni6ZhFXiBSgyEnaiCgoZdj4hveMcQmGfRmQK1MrrsfWhetq2VFNcnHgJeSqgBK4"
//     )
//   );

//   console.log("- front user", frontUser.publicKey.toBase58());

//   const otherUserForClaim = Keypair.generate();

//   const [shuihuAddress, shuihuBump] = web3.PublicKey.findProgramAddressSync(
//     [Buffer.from(SHUIHU_SEED)],
//     program.programId
//   );

//   const [tokenMintAddress, tokenMintBump] =
//     web3.PublicKey.findProgramAddressSync(
//       [TOKEN_MINT, shuihuAddress.toBuffer()],
//       program.programId
//     );

//   const testUserTokenAccount = getAssociatedTokenAddressSync(
//     tokenMintAddress,
//     testUser.publicKey,
//     false,
//     TOKEN_2022_PROGRAM_ID
//   );

//   let claimEventCalled = false;
//   let claimEventData = null;
//   let claimEventListener: any = null;
//   let mintEventCalled = false;
//   let mintEventData = null;
//   let mintEventListener: any = null;

//   group(" ----- addresses list ");
//   log("shuihu", shuihuAddress.toBase58());
//   log("team", team.toBase58());
//   log("token_mint", tokenMintAddress.toBase58());
//   log("hero_collection", heroCollection.publicKey.toBase58());
//   log("testUser", testUser.publicKey.toBase58());
//   log("testUserTokenAccount", testUserTokenAccount.toBase58());
//   log("- wallet", wallet.publicKey.toBase58());
//   groupEnd();

//   beforeAll(async () => {
//     vrfTestHelper = await OraoVrfTestHelper.create(provider);
//     console.log(
//       "treasuryAccount",
//       vrfTestHelper.treasuryAccount.publicKey.toBase58()
//     );
//     await airdropToAcc(testUser.publicKey, 1000);
//     await airdropToAcc(wrongMintUser.publicKey, 20);
//     await airdropToAcc(wrongCollectUser.publicKey, 20);
//     await airdropToAcc(wrongCombineUser.publicKey, 20);
//     await airdropToAcc(claimer1.publicKey, 1000);
//     await airdropToAcc(claimer2.publicKey, 1000);
//     await airdropToAcc(frontUser.publicKey, 100);

//     claimEventListener = program.addEventListener(
//       "claimEvent",
//       (event, slot, signature) => {
//         claimEventCalled = true;
//         claimEventData = event;
//         log("- claim Event listener", event);
//         log("- claim Event slot", event);
//         log("- claim Event sig", signature);
//       }
//     );
//     mintEventListener = program.addEventListener(
//       "mintEvent",
//       (event, slot, signature) => {
//         mintEventCalled = true;
//         mintEventData = event;
//         // console.log("- event", event);
//       }
//     );
//   });

//   afterAll(() => {
//     program.removeEventListener(claimEventListener);
//   });

//   const airdropToAcc = async (acc: PublicKey, amount: number = 1) => {
//     await provider.connection.requestAirdrop(acc, amount * LAMPORTS_PER_SOL);
//   };

//   const vrfFullFilled = async (force: PublicKey) => {
//     await vrfTestHelper.mockFulfillment(force.toBuffer());
//     await vrfTestHelper.waitFulfilled(force.toBuffer());
//   };

//   const mintAndRevealHero = async (user: Keypair) => {
//     let hero = Keypair.generate();
//     // mint hero
//     await program.methods
//       .mint(hero.publicKey)
//       .accounts({
//         minter: user.publicKey,
//         treasury: vrfTestHelper.treasuryAccount.publicKey,
//       })
//       .signers([user])
//       .rpc();

//     // vrf full filled
//     await vrfFullFilled(hero.publicKey);

//     // reveal hero
//     await program.methods
//       .reveal()
//       .accounts({
//         minter: user.publicKey,
//         hero: hero.publicKey,
//         treasury: vrfTestHelper.treasuryAccount.publicKey,
//       })
//       .signers([user, hero])
//       .rpc();

//     return hero;
//   };

//   const mintHeroIndexed = async (user: Keypair, index: number) => {
//     let hero = Keypair.generate();

//     await program.methods
//       .revealIndex(index)
//       .accounts({
//         minter: user.publicKey,
//         hero: hero.publicKey,
//       })
//       .signers([user, hero])
//       .rpc();

//     return hero;
//   };

//   const collectHero = async (user: Keypair, hero: PublicKey) => {
//     await program.methods
//       .collect()
//       .accounts({
//         hero: hero,
//         minter: user.publicKey,
//       })
//       .signers([user])
//       .rpc();
//   };

//   const collectAllHeroForAUser = async (
//     col_user: Keypair,
//     nickname: string
//   ) => {
//     log(
//       chalk.green(
//         `üî® ÂºÄÂßã‰∏∫Áî®Êà∑ ${nickname} : ${col_user.publicKey.toBase58()} Êî∂ÈõÜËã±ÈõÑ`
//       )
//     );

//     // 1.1 ËÆ°ÁÆóÊî∂ËóèÂÜåpdaÂú∞ÂùÄ
//     const [userColAddr] = PublicKey.findProgramAddressSync(
//       [USER_COLLECTION_SEED, col_user.publicKey.toBuffer()],
//       program.programId
//     );

//     // 1.2 Ëé∑ÂèñÊî∂ËóèÂÜå‰ø°ÊÅØ
//     let userColl = await program.account.userCollection
//       .fetch(userColAddr)
//       .catch(() => null);

//     // 1.3 ËÆ°ÁÆóÈúÄË¶ÅÊî∂ÈõÜÁöÑËã±ÈõÑÁ¥¢Âºï
//     let neededHeroesToCollection = [];
//     if (!userColl) {
//       neededHeroesToCollection = Array.from(
//         { length: 108 },
//         (_, index) => index
//       );
//     } else {
//       neededHeroesToCollection = userColl.collection
//         .map((value, index) => ({ value, index }))
//         .filter((item) => item.value === 0)
//         .map((item) => item.index);
//     }

//     // 2. Èì∏ÈÄ†Ëã±ÈõÑ
//     const mintPromises = neededHeroesToCollection.map(async (index) => {
//       const hero = await mintHeroIndexed(col_user, index);
//       return { index, hero };
//     });

//     const mintedHeroes = await Promise.all(mintPromises);
//     // 3. Êî∂ËóèËã±ÈõÑ
//     const collectPromises = mintedHeroes.map(async ({ index, hero }) => {
//       await collectHero(col_user, hero.publicKey);
//       return index;
//     });

//     await Promise.all(collectPromises);
//     // 3.1 È™åËØÅËã±ÈõÑÈì∏ÈÄ†Áä∂ÊÄÅ

//     // 4. È™åËØÅËã±ÈõÑÊòØÂê¶ÊàêÂäüÊî∂Ëóè
//     const updatedUserCol = await program.account.userCollection.fetch(
//       userColAddr
//     );

//     assert.equal(
//       updatedUserCol.collection.length,
//       108,
//       "‚úÖ Áî®Êà∑Êú™ÊàêÂäüÊî∂ÈõÜÊâÄÊúâËã±ÈõÑ"
//     );

//     log(chalk.bgGreen(`üåü ${nickname} Â∑≤Êî∂ÈõÜÈΩêÊâÄÊúâËã±ÈõÑ`));
//   };

//   it("1. ÂàùÂßãÂåñÈ°πÁõÆ - Initialize ShuihuDapp", async () => {
//     await program.methods
//       .initialize(new BN(1735660800), team) // 2025 1.1
//       // .initialize(new BN(1748764800), team)
//       .accounts({
//         heroCollection: heroCollection.publicKey,
//         payer: wallet.publicKey,
//       })
//       .signers([wallet.payer, heroCollection])
//       .rpc();

//     // 1. Ëé∑ÂèñÊ∞¥ÊµíË¥¶Êà∑‰ø°ÊÅØ
//     const shuihu_account = await program.account.shuiHu.fetch(shuihuAddress);
//     console.log("- shuihu account ", shuihu_account);
//     assert.equal(shuihu_account.round, START_ROUND);
//     assert.equal(shuihu_account.mintPrice.toNumber(), START_MINT_PRICE);

//     // 2. Ëé∑Âèñtoken mint ‰ø°ÊÅØ
//     const token_mint_account = await provider.connection.getTokenSupply(
//       tokenMintAddress
//     );
//     assert.ok(token_mint_account.value.uiAmount == 0);

//     // 3. Ëé∑ÂèñËã±ÈõÑÂêàÈõÜ‰ø°ÊÅØ
//     try {
//       const collection = await fetchCollection(
//         umi,
//         heroCollection.publicKey.toBase58(),
//         {
//           commitment: "confirmed",
//         }
//       );

//       assert.equal(
//         collection.name,
//         "SHUI HU HERO COLLECTION",
//         "ÂêàÈõÜÂêçÁß∞‰∏çÊ≠£Á°Æ"
//       );
//       assert.equal(collection.numMinted, 0, "ÂêàÈõÜmintÊï∞Èáè‰∏çÊ≠£Á°Æ");
//       assert.equal(
//         collection.publicKey,
//         heroCollection.publicKey.toBase58(),
//         "ÂêàÈõÜÂú∞ÂùÄ‰∏çÊ≠£Á°Æ"
//       );
//       assert.equal(collection.currentSize, 0, "ÂêàÈõÜÂΩìÂâçÊï∞ÈáèÊï∞Èáè‰∏çÊ≠£Á°Æ");
//       assert.equal(
//         collection.updateAuthority,
//         shuihuAddress.toBase58(),
//         "ÂêàÈõÜÊõ¥Êñ∞ÊùÉÈôê‰∏çÊòØÂêàÁ∫¶pda"
//       );
//     } catch (error) {
//       assert.fail("Ëé∑ÂèñËã±ÈõÑÂêàÈõÜ‰ø°ÊÅØÊó∂Âá∫Èîô", error);
//     }
//   });

//   // it(
//   //   "2. ÁªôÂâçÁ´ØÁî®Êî∂ÈõÜÈΩêËã±ÈõÑ",
//   //   async () => {
//   //     await collectAllHeroForAUser(frontUser, "front");
//   //   },
//   //   30 * 1000
//   // );

//   it("2. Èì∏ÈÄ†Âç°Áâá - Mint A Card Test Unit", async () => {
//     const hero = Keypair.generate();
//     log("Ëã±ÈõÑÂÖ¨Èí•:", hero.publicKey.toString());
//     // 1. Ëé∑ÂèñÈì∏ÈÄ†ÂâçÁä∂ÊÄÅ Get shuihu account info before mint
//     const shuihuBefore = await program.account.shuiHu.fetch(shuihuAddress);
//     const userBalanceBefore = await provider.connection.getBalance(
//       testUser.publicKey
//     );
//     // 2. Èì∏ÈÄ†Âç°Áâá mint card
//     const mintTx = await program.methods
//       .mint(hero.publicKey)
//       .accounts({
//         minter: testUser.publicKey,
//         treasury: vrfTestHelper.treasuryAccount.publicKey,
//       })
//       .signers([testUser])
//       .rpc({
//         skipPreflight: true,
//       });

//     log("Èì∏ÈÄ†‰∫§Êòì:", mintTx);

//     // 3. È™åËØÅÈì∏ÈÄ†ÂêéÁä∂ÊÄÅ get shuihu account info after mint
//     const shuihuAfter = await program.account.shuiHu.fetch(shuihuAddress);

//     // 3.1 È™åËØÅÂ•ñÊ±†Â¢ûÂä† verify the bonus increase correctly
//     assert.equal(
//       shuihuAfter.bonus.toNumber(),
//       shuihuBefore.bonus.toNumber() + START_MINT_PRICE,
//       "Â•ñÊ±†ÈáëÈ¢ùÊú™Ê≠£Á°ÆÂ¢ûÂä†"
//     );

//     // 3.2 È™åËØÅÈì∏ÈÄ†Áä∂ÊÄÅ verify the mint state pda account
//     const [heroMintStateAddress] = PublicKey.findProgramAddressSync(
//       [MINT_STATE_SEED, hero.publicKey.toBuffer()],
//       program.programId
//     );
//     const heroMintState = await program.account.heroMintState.fetch(
//       heroMintStateAddress
//     );
//     assert.equal(
//       heroMintState.minter.toString(),
//       testUser.publicKey.toString(),
//       "Èì∏ÈÄ†ËÄÖ‰∏çÂåπÈÖç"
//     );
//     assert.equal(
//       heroMintState.hero.toString(),
//       hero.publicKey.toString(),
//       "Ëã±ÈõÑÂÖ¨Èí•‰∏çÂåπÈÖç"
//     );
//     assert.equal(heroMintState.minted, false, "Èì∏ÈÄ†Áä∂ÊÄÅÈîôËØØ");

//     log(`‚úÖ Èì∏ÈÄ†Áä∂ÊÄÅÈ™åËØÅÈÄöËøá`);

//     // 3.3 È™åËØÅÁî®Êà∑Áä∂ÊÄÅ - verify the user balance change
//     const userBalanceAfter = await provider.connection.getBalance(
//       testUser.publicKey
//     );
//     console.log("Èì∏ÈÄ†ÂêéÁî®Êà∑‰ΩôÈ¢ù:", userBalanceAfter / LAMPORTS_PER_SOL, "SOL");
//     const userBalanceChange = userBalanceBefore - userBalanceAfter;
//     assert.equal(
//       userBalanceChange > START_MINT_PRICE,
//       true,
//       "Áî®Êà∑‰ΩôÈ¢ùÊú™Ê≠£Á°ÆÂáèÂ∞ë"
//     );

//     log(
//       `‚úÖ Áî®Êà∑‰ΩôÈ¢ùÁä∂ÊÄÅÈ™åËØÅÈÄöËøá, ‰ΩôÈ¢ùÂèòÂåñ ${
//         userBalanceChange / LAMPORTS_PER_SOL
//       } SOL`
//     );

//     // 3.4 È™åËØÅÁî®Êà∑Ëé∑ÂæóÊ∞¥ÊµíÂÖÉÂÆù verify the user token balance
//     try {
//       const tokenBalance = await provider.connection.getTokenAccountBalance(
//         testUserTokenAccount
//       );
//       log("Áî®Êà∑ÂÖÉÂÆù‰ΩôÈ¢ù:", tokenBalance.value.uiAmount);
//       assert.equal(
//         tokenBalance.value.uiAmount,
//         START_MINT_PRICE / LAMPORTS_PER_SOL,
//         "Áî®Êà∑Êú™Ëé∑ÂæóÊ≠£Á°ÆÊï∞ÈáèÁöÑÊ∞¥ÊµíÂÖÉÂÆù"
//       );

//       log(`‚úÖ Áî®Êà∑ÂÖÉÂÆùÈ™åËØÅÈÄöËøáÔºå ÂÖÉÂÆù‰ΩôÈ¢ù: ${tokenBalance.value.uiAmount}`);
//     } catch (e) {
//       console.error("Ëé∑Âèñ‰ª£Â∏Å‰ΩôÈ¢ùÂ§±Ë¥•:", e);
//       assert.fail("Ëé∑Âèñ‰ª£Â∏Å‰ΩôÈ¢ùÂ§±Ë¥•");
//     }

//     // 4. È™åËØÅ‰∫ã‰ª∂Ëß¶Âèë - verify the mint event
//     assert.ok(mintEventCalled, "MintEvent ‰∫ã‰ª∂Ê≤°ÊúâË¢´Ëß¶Âèë");
//     assert.ok(mintEventData!.round === START_ROUND, "‰∫ã‰ª∂‰∏≠ÁöÑ round ‰∏çÊ≠£Á°Æ");
//     assert.ok(
//       mintEventData!.bonus.eq(new BN(START_MINT_PRICE)),
//       "‰∫ã‰ª∂‰∏≠ÁöÑ bonus ‰∏çÊ≠£Á°Æ"
//     );
//     assert.ok(
//       mintEventData!.minter.equals(testUser.publicKey),
//       "‰∫ã‰ª∂‰∏≠ÁöÑ minter ‰∏çÊ≠£Á°Æ"
//     );

//     log(`‚úÖ Mint ‰∫ã‰ª∂Êé•Êî∂È™åËØÅÈÄöËøá`);

//     // 5. ÊµãËØïËæπÁïåÊÉÖÂÜµÔºö‰ΩøÁî®Èõ∂Âú∞ÂùÄÈì∏ÈÄ† - test the zero seed minting
//     try {
//       await program.methods
//         .mint(PublicKey.default)
//         .accounts({
//           minter: testUser.publicKey,
//           treasury: vrfTestHelper.treasuryAccount.publicKey,
//         })
//         .signers([testUser])
//         .rpc();
//       assert.fail("‰ΩøÁî®Èõ∂Âú∞ÂùÄÈì∏ÈÄ†Â∫îËØ•Â§±Ë¥•");
//     } catch (error: any) {
//       log(`‚úÖ Mint seedÈõ∂Âú∞ÂùÄÈì∏ÈÄ†,È™åËØÅÈÄöËøá`);
//       assert.include(
//         error.message,
//         "VrfSeedIllegal",
//         "Â∫îËØ•ËøîÂõûVrfSeedIllegalÈîôËØØ"
//       );
//     }

//     // 6. ÊµãËØïËæπÁïåÊÉÖÂÜµÔºå 0 Sol mint
//     try {
//       let newHero = Keypair.generate();
//       await program.methods
//         .mint(newHero.publicKey)
//         .accounts({
//           minter: testUser2.publicKey,
//           treasury: vrfTestHelper.treasuryAccount.publicKey,
//         })
//         .signers([testUser2])
//         .rpc();

//       assert.fail("Èõ∂ SOL Áî®Êà∑Èì∏ÈÄ†Â∫îËØ•Â§±Ë¥•");
//     } catch (error: any) {
//       log(`‚úÖ 0 SOL MINT,È™åËØÅÈÄöËøá`);
//       assert.ok(
//         error.logs.some((log: string) => log.includes("insufficient lamports")),
//         "Â∫îËØ•ÂåÖÂê´‰ΩôÈ¢ù‰∏çË∂≥Ôºåinsufficient lamports"
//       );
//     }

//     // 7. ÊµãËØïÂ∑≤‰ΩøÁî®ËøáÁöÑ vrf seed Èì∏ÈÄ† - test use minted vrf seed minting
//     try {
//       await program.methods
//         .mint(hero.publicKey)
//         .accounts({
//           minter: testUser.publicKey,
//           treasury: vrfTestHelper.treasuryAccount.publicKey,
//         })
//         .signers([testUser])
//         .rpc();

//       assert.fail("Â∑≤‰ΩøÁî®ËøáÁöÑ vrf Seed ÂÜçÊ¨°Èì∏ÈÄ†Â∫îËØ•Â§±Ë¥•");
//     } catch (error: any) {
//       log(`‚úÖ Â∑≤‰ΩøÁî®ËøáÂæó vrf seed ÈáçÂ§çÈì∏ÈÄ†,È™åËØÅÈÄöËøá`);
//       assert.ok(
//         error.logs.some((log: string) => log.includes("already in use")),
//         "Â∫îËØ•ÊòæÁ§∫Ôºåalready in use"
//       );
//     }
//   });

//   it(
//     "3. Êè≠Á§∫Ëã±ÈõÑ - Reveal A Hero Test Unit",
//     async () => {
//       // 1. Èì∏ÈÄ† + Êè≠Á§∫‰∏Ä‰∏™Ëã±ÈõÑ mint and reveal a hero
//       // 1.1 ÂàõÂª∫Âç°Áâá
//       const hero = Keypair.generate();

//       // 1.2 Èì∏ÈÄ†Âç°Áâá mint a card first
//       await program.methods
//         .mint(hero.publicKey)
//         .accounts({
//           minter: testUser.publicKey,
//           treasury: vrfTestHelper.treasuryAccount.publicKey,
//         })
//         .signers([testUser])
//         .rpc();

//       // 2. Ëé∑ÂèñÈì∏ÈÄ†Áä∂ÊÄÅË¥¶Êà∑Âú∞ÂùÄ - get the mint state account address
//       const [heroMintStateAddress] = PublicKey.findProgramAddressSync(
//         [MINT_STATE_SEED, hero.publicKey.toBuffer()],
//         program.programId
//       );

//       // 2.1. Ëé∑ÂèñÈì∏ÈÄ†Áä∂ÊÄÅ - get the mint state account pda info
//       let heroMintState = await program.account.heroMintState.fetch(
//         heroMintStateAddress
//       );

//       // 2.2 Èì∏ÈÄ†Áä∂ÊÄÅÈ™åËØÅ - verify the mint state pda account
//       assert.equal(
//         heroMintState.minter.toString(),
//         testUser.publicKey.toString(),
//         "Èì∏ÈÄ†ËÄÖ‰∏çÂåπÈÖç"
//       );
//       assert.equal(
//         heroMintState.hero.toString(),
//         hero.publicKey.toString(),
//         "Ëã±ÈõÑÂÖ¨Èí•‰∏çÂåπÈÖç"
//       );
//       assert.equal(heroMintState.minted, false, "Èì∏ÈÄ†Áä∂ÊÄÅÈîôËØØ");

//       // 3. Á≠âÂæÖVRFÈöèÊú∫Êï∞ÁîüÊàê
//       await vrfFullFilled(hero.publicKey);

//       // 4. Êè≠Á§∫Ëã±ÈõÑ - reveal hero
//       try {
//         const revealTx = await program.methods
//           .reveal()
//           .accounts({
//             minter: testUser.publicKey,
//             hero: hero.publicKey,
//             treasury: vrfTestHelper.treasuryAccount.publicKey,
//           })
//           .signers([testUser, hero])
//           .rpc();

//         log("Êè≠Á§∫‰∫§Êòì:", revealTx);
//         const latestBlockHash = await provider.connection.getLatestBlockhash();
//         await provider.connection.confirmTransaction(
//           {
//             signature: revealTx,
//             ...latestBlockHash,
//           },
//           "confirmed"
//         );

//         assert.ok(true, "‚úÖ Êè≠Á§∫‰∫§ÊòìÂÆåÊàê");
//       } catch (error: any) {
//         console.error("‚ùå Êè≠Á§∫Â§±Ë¥•:", error);
//         assert.fail("Ëã±ÈõÑÊè≠Á§∫Â∫îËØ•ÊàêÂäü");
//       }

//       // 5. È™åËØÅÊè≠Á§∫ÂêéÁöÑÈì∏ÈÄ†Áä∂ÊÄÅ - verify the mint state pda account
//       heroMintState = await program.account.heroMintState.fetch(
//         heroMintStateAddress
//       );
//       assert.equal(heroMintState.minted, true, "Êè≠Á§∫ÂêéÈì∏ÈÄ†Áä∂ÊÄÅÂ∫î‰∏∫true");
//       assert.equal(
//         heroMintState.minter.toString(),
//         testUser.publicKey.toString(),
//         "Èì∏ÈÄ†ËÄÖ‰∏éÊè≠ÊôìËÄÖ‰∏Ä‰∏ç‰∏ÄËá¥"
//       );
//       assert.notDeepEqual(
//         heroMintState.randomness,
//         new Array(64).fill(0),
//         "ÈöèÊú∫Êï∞Â∫îËØ•Â∑≤ËÆæÁΩÆ"
//       );
//       assert.isAtLeast(heroMintState.result, 0, "Ëã±ÈõÑÁ¥¢ÂºïÂ∫îËØ•Â§ß‰∫éÁ≠â‰∫é0");
//       assert.isBelow(heroMintState.result, 108, "Ëã±ÈõÑÁ¥¢ÂºïÂ∫îËØ•Â∞è‰∫é108");

//       // 5.1 ÈöèÊú∫Êï∞ËÆ°ÁÆóÁ¥¢ÂºïÈ™åËØÅ - cal the hero index from the randomness has
//       let cal_hero_index = calHeroIndex(heroMintState.randomness);
//       assert.equal(
//         heroMintState.result,
//         cal_hero_index,
//         "ËÆ°ÁÆóÁöÑËã±ÈõÑÁ¥¢Âºï‰∏éÈì∏ÈÄ†Áä∂ÊÄÅ‰∏≠Ëã±ÈõÑÁ¥¢Âºï‰∏çÁ¨¶"
//       );

//       // 6. Ëã±ÈõÑNFTË¥¶Êà∑È™åËØÅ - verify the hero nft account
//       const heroAccountInfo = await provider.connection.getAccountInfo(
//         hero.publicKey
//       );
//       assert.isNotNull(heroAccountInfo, "Ëã±ÈõÑNFTË¥¶Êà∑Â∫îËØ•Â≠òÂú®");

//       // 6.1 NFT ‰ø°ÊÅØÈ™åËØÅ - verify the hero nft info
//       try {
//         const hero_assets = await fetchAsset(umi, hero.publicKey.toBase58(), {
//           skipDerivePlugins: false,
//         });
//         assert.equal(hero_assets.publicKey, hero.publicKey.toBase58());
//         assert.equal(
//           hero_assets.updateAuthority.address,
//           heroCollection.publicKey.toBase58(),
//           "Ëã±ÈõÑ update ÊùÉÈôê Â∫îËØ•Â±û‰∫éÂêàÈõÜ"
//         );
//         assert.equal(
//           hero_assets.name,
//           `SHUI HU HERO #${heroMintState.result + 1}`,
//           `Ëã±ÈõÑÂêçÁß∞ Â∫îËØ•ÊòØ: SHUI HU HERO #${heroMintState.result}`
//         );

//         let asset_star = hero_assets.attributes?.attributeList.find(
//           (attr) => attr.key === "Star"
//         )?.value;
//         assert.isNotNull(asset_star, "Ëã±ÈõÑ star Â±ûÊÄß‰∏ç‰∏∫Á©∫");

//         let asset_index = hero_assets.attributes?.attributeList.find(
//           (attr) => attr.key === "Index"
//         )?.value;
//         assert.isNotNull(asset_index, "Ëã±ÈõÑ index Â±ûÊÄß‰∏ç‰∏∫Á©∫");
//         assert.equal(
//           Number(asset_index),
//           heroMintState.result,
//           "Ëã±ÈõÑIndexÂ±ûÊÄßÔºåÂ∫îËØ•Á≠â‰∫éÈì∏ÈÄ†Áä∂ÊÄÅ‰∏≠ÁöÑÁªìÊûú"
//         );

//         let find_star = hero_list.find((hero, index) => {
//           return index === heroMintState.result;
//         })?.star;

//         assert.equal(
//           find_star,
//           Number(asset_star),
//           "Êü•ÊâæÁöÑÊòüÊï∞ Â∫îËØ•Á≠â‰∫éÂ±ûÊÄßÊòüÊï∞"
//         );

//         log(`‚úÖ Ëã±ÈõÑNFT‰ø°ÊÅØÈ™åËØÅÈÄöËøá`);
//       } catch (e) {
//         assert.fail("Ëé∑ÂèñËã±ÈõÑNFT‰ø°ÊÅØÊó∂Âá∫Èîô", e);
//       }

//       // 7. ÊµãËØïÈáçÂ§çÊè≠Á§∫Â∫îËØ•Â§±Ë¥• - test the repeat reveal should fail
//       try {
//         await program.methods
//           .reveal()
//           .accounts({
//             minter: testUser.publicKey,
//             hero: hero.publicKey,
//             treasury: vrfTestHelper.treasuryAccount.publicKey,
//           })
//           .signers([testUser, hero])
//           .rpc();
//         assert.fail("ÈáçÂ§çÊè≠Á§∫Â∫îËØ•Â§±Ë¥•");
//       } catch (error: any) {
//         assert.include(
//           error.message,
//           "AlreadyMinted",
//           "Â∫îËØ•ËøîÂõûAlreadyMintedÈîôËØØ"
//         );
//       }

//       // 8. ÊµãËØïÈîôËØØÁöÑÈì∏ÈÄ†ËÄÖÊè≠Á§∫Â∫îËØ•Â§±Ë¥• - test the wrong minter reveal should fail
//       try {
//         const wrongMintUserTestHero = Keypair.generate();

//         // 8.1 testUser ÂÖàÈì∏ÈÄ†‰∏Ä‰∏™Âç°Áâá
//         await program.methods
//           .mint(wrongMintUserTestHero.publicKey)
//           .accounts({
//             minter: testUser.publicKey,
//             treasury: vrfTestHelper.treasuryAccount.publicKey,
//           })
//           .signers([testUser])
//           .rpc();

//         await program.methods
//           .reveal()
//           .accounts({
//             minter: wrongMintUser.publicKey,
//             hero: wrongMintUserTestHero.publicKey,
//             treasury: vrfTestHelper.treasuryAccount.publicKey,
//           })
//           .signers([wrongMintUser, wrongMintUserTestHero])
//           .rpc();

//         assert.fail("ÈîôËØØÁöÑÈì∏ÈÄ†ËÄÖÊè≠Á§∫Â∫îËØ•Â§±Ë¥•");
//       } catch (error: any) {
//         // log("‚úÖ 8.1 ÈîôËØØÁöÑÊè≠Á§∫ËÄÖÔºåÈ¢ÑÊúüÁöÑÈîôËØØ:", error.message);
//         assert.include(
//           error.message,
//           "Invalid Minter",
//           "Â∫îËØ•ËøîÂõû Invalid Minter ÈîôËØØ"
//         );
//       }
//     },
//     1000 * 20
//   );

//   it(
//     "4. Ëã±ÈõÑÊî∂ÈõÜ - Collect Hero Test Unit ",
//     async () => {
//       // 1. ÂÖàÈì∏ÈÄ†Âπ∂Êè≠Á§∫‰∏Ä‰∏™Ëã±ÈõÑ mint and reveal a hero
//       const hero = await mintHeroIndexed(testUser, 0);

//       // 1.1. ËÆ°ÁÆóÁî®Êà∑Ëã±ÈõÑÈõÜÂêàÂú∞ÂùÄ - cal the user collection address
//       const [userCollectionAddress] = PublicKey.findProgramAddressSync(
//         [USER_COLLECTION_SEED, testUser.publicKey.toBuffer()],
//         program.programId
//       );
//       log("üìö test user Ëã±ÈõÑÈõÜÂêàÂú∞ÂùÄ:", userCollectionAddress.toString());

//       // 2. Êî∂ÈõÜËã±ÈõÑ - collect hero
//       try {
//         const collectTx = await program.methods
//           .collect()
//           .accounts({
//             minter: testUser.publicKey,
//             hero: hero.publicKey,
//           })
//           .signers([testUser])
//           .rpc();
//         console.log("‚úÖ Êî∂ÈõÜ‰∫§ÊòìÂÆåÊàê:", collectTx);
//       } catch (error: any) {
//         console.error("‚ùå Êî∂ÈõÜËã±ÈõÑÂ§±Ë¥•:", error);
//         assert.fail("Ëã±ÈõÑÊî∂ÈõÜÂ∫îËØ•ÊàêÂäü");
//       }

//       // 3. Êî∂ÈõÜÈ™åËØÅ - verify the collect
//       // 3.1 Ëé∑ÂèñtestUserËã±ÈõÑÈõÜÂêà‰ø°ÊÅØ - get the user collection info
//       const userCollection = await program.account.userCollection.fetch(
//         userCollectionAddress
//       );

//       // 3.2 Âú∞ÂùÄÈ™åËØÅ - verify the user collection address
//       assert.equal(
//         userCollection.minter.toString(),
//         testUser.publicKey.toString(),
//         "Áî®Êà∑Âú∞ÂùÄ‰∏çÂåπÈÖç"
//       );

//       // 3.3 È™åËØÅÊòØÂê¶Êî∂ÈõÜÊàêÂäü - verify the collect
//       assert.equal(userCollection.collection[0], 1, "Ëã±ÈõÑÊú™Ë¢´ÊàêÂäüÊî∂ÈõÜ");

//       // 3.4 È™åËØÅÈõÜÂêàÊï∞ÁªÑ - verify the collection array
//       let collectedCount = 0;
//       for (let i = 0; i < userCollection.collection.length; i++) {
//         if (userCollection.collection[i] === 1) {
//           collectedCount++;
//           console.log(`üåü Â∑≤Êî∂ÈõÜËã±ÈõÑÁ¥¢Âºï: ${i}`);
//         }
//       }
//       assert.equal(collectedCount, 1, "Â∫îËØ•Âè™Êî∂ÈõÜ‰∫Ü‰∏Ä‰∏™Ëã±ÈõÑ");

//       // // 4. È™åËØÅËã±ÈõÑNFTÊòØÂê¶Â∑≤ÈîÄÊØÅ - verify the hero nft is destroyed
//       // // 4.1 È™åËØÅ NFT ÊòØÂê¶Â∑≤ÈîÄÊØÅ ÔºàMPL - ÂêàÈõÜÔºâ
//       // try {
//       //   const collection = await fetchCollection(
//       //     umi,
//       //     heroCollection.publicKey.toBase58(),
//       //     {
//       //       commitment: "confirmed",
//       //     }
//       //   );
//       //   assert.equal(
//       //     collection.numMinted - collection.currentSize,
//       //     1,
//       //     "ÂêàÈõÜÊï∞ÊçÆ‰∏≠ÔºåÊòæÁ§∫ÁöÑNFTÂ∑≤ÈîÄÊØÅÊï∞ÈáèÂ∫îËØ•‰∏∫1"
//       //   );
//       // } catch (e) {
//       //   assert.fail("Ëé∑ÂèñMPLÂêàÈõÜ‰ø°ÊÅØ‰ø°ÊÅØÊó∂Âá∫Èîô", e);
//       // }

//       // 4.2 È™åËØÅ NFT ÊòØÂê¶Â∑≤ÈîÄÊØÅ ÔºàMPL - ÂçïNFTÔºâ - verify the hero nft is destroyed
//       try {
//         const hero_assets = await fetchAsset(umi, hero.publicKey.toBase58(), {
//           skipDerivePlugins: false,
//         });
//         assert.fail("Ëã±ÈõÑÂ∫îËØ•Â∑≤Ë¢´ÈîÄÊØÅ");
//       } catch (e: any) {
//         assert.include(
//           e.message,
//           "is not of the expected type",
//           "‰∏çÊòØÊúüÊúõÁöÑË¥¶Êà∑Á±ªÂûã‰∫Ü"
//         );
//       }

//       // 5. ÊµãËØïÈáçÂ§çÊî∂ÈõÜÂêå‰∏Ä‰∏™Ëã±ÈõÑÂ∫îËØ•Â§±Ë¥• - test the repeat collect the same hero should fail
//       // 5.1 Âú®Èì∏ÈÄ†‰∏Ä‰∏™0Âè∑Ëã±ÈõÑ - mint a new hero
//       const repeat_col_hero = await mintHeroIndexed(testUser, 0);
//       try {
//         // 5.2 ÈáçÂ§çÊî∂ÈõÜ
//         await program.methods
//           .collect()
//           .accounts({
//             minter: testUser.publicKey,
//             hero: repeat_col_hero.publicKey,
//           })
//           .signers([testUser])
//           .rpc();
//         assert.fail("ÈáçÂ§çÊî∂ÈõÜÂêå‰∏Ä‰∏™Ëã±ÈõÑÂ∫îËØ•Â§±Ë¥•");
//       } catch (error: any) {
//         console.log("‚úÖ 5. ÈáçÂ§çÊî∂ÈõÜËã±ÈõÑ È¢ÑÊúüÁöÑÈîôËØØ:", error.message);
//         assert.include(
//           error.message,
//           "HeroAlreadyCollected",
//           "ËØ•Ëã±ÈõÑÂ∫îËØ•Â∑≤Ë¢´Êî∂ÈõÜ"
//         );
//       }

//       // 6. ÊµãËØïÈîôËØØÁöÑÁî®Êà∑Êî∂ÈõÜËã±ÈõÑ - test the wrong user collect hero
//       try {
//         // 6.1 Èì∏ÈÄ†‰∏Ä‰∏™Êñ∞Ëã±ÈõÑ - mint a new hero
//         const wrong_col_user_test_hero = await mintAndRevealHero(testUser);

//         // 6.2 ÊµãËØïÊî∂ÈõÜ - test collect
//         await program.methods
//           .collect()
//           .accounts({
//             minter: wrongCollectUser.publicKey,
//             hero: wrong_col_user_test_hero.publicKey,
//           })
//           .signers([wrongCollectUser])
//           .rpc();
//         assert.fail("ÈîôËØØÁöÑÁî®Êà∑Êî∂ÈõÜËã±ÈõÑÂ∫îËØ•Â§±Ë¥•");
//       } catch (error: any) {
//         assert.include(
//           error.message,
//           "InvalidHeroOwner",
//           "Â∫îËØ•ËøîÂõûInvalidHeroOwnerÈîôËØØ"
//         );
//       }
//     },
//     1000 * 60
//   );

//   it(
//     "5. ÂêàÊàêËã±ÈõÑ - Combine Heroes Test Unit",
//     async () => {
//       // 1. ÂÖàÈì∏ÈÄ†Âπ∂Êè≠Á§∫‰∏§‰∏™Ëã±ÈõÑ - mint and reveal two heroes
//       const hero1 = await mintAndRevealHero(testUser);
//       const hero2 = await mintAndRevealHero(testUser);

//       // 1.1. ÂàõÂª∫Êñ∞Ëã±ÈõÑÁöÑÁßçÂ≠ê - create the seed for the new hero
//       const newHero = Keypair.generate();

//       // 2. ÂêàÊàêËã±ÈõÑ - combine heroes
//       try {
//         const combineTx = await program.methods
//           .combine(newHero.publicKey)
//           .accounts({
//             minter: testUser.publicKey,
//             hero1: hero1.publicKey,
//             hero2: hero2.publicKey,
//             treasury: vrfTestHelper.treasuryAccount.publicKey,
//           })
//           .signers([testUser])
//           .rpc();

//         console.log("‚úÖ ÂêàÊàê‰∫§ÊòìÂÆåÊàê:", combineTx);
//       } catch (error: any) {
//         assert.fail("Ëã±ÈõÑÂêàÊàêÂ∫îËØ•ÊàêÂäü", error.message);
//       }

//       // 3. È™åËØÅ - verify
//       // 3.1 Ëé∑ÂèñÈì∏ÈÄ†Áä∂ÊÄÅÂú∞ÂùÄÔºåÂèä‰ø°ÊÅØ - get the mint state address and info
//       const [heroMintStateAddress] = PublicKey.findProgramAddressSync(
//         [MINT_STATE_SEED, newHero.publicKey.toBuffer()],
//         program.programId
//       );
//       let heroMintState = await program.account.heroMintState.fetch(
//         heroMintStateAddress
//       );

//       // 3.2 Èì∏ÈÄ†Áä∂ÊÄÅÂà§Êñ≠ - verify the mint state
//       assert.equal(
//         heroMintState.minter.toString(),
//         testUser.publicKey.toString(),
//         "Èì∏ÈÄ†ËÄÖ‰∏çÂåπÈÖç"
//       );
//       assert.equal(
//         heroMintState.hero.toString(),
//         newHero.publicKey.toString(),
//         "Ëã±ÈõÑÂÖ¨Èí•‰∏çÂåπÈÖç"
//       );
//       assert.equal(heroMintState.minted, false, "Èì∏ÈÄ†Áä∂ÊÄÅÈîôËØØ");

//       // 3.3. È™åËØÅ ÂéüËã±ÈõÑÊòØÂê¶Â∑≤ÈîÄÊØÅ - verify the hero is destroyed
//       try {
//         await fetchAsset(umi, hero1.publicKey.toBase58(), {
//           skipDerivePlugins: false,
//         });
//         assert.fail("Ëã±ÈõÑÂ∫îËØ•Â∑≤Ë¢´ÈîÄÊØÅ");
//       } catch (e: any) {
//         // console.log("‚úÖ Ëã±ÈõÑ1Â∑≤ÊàêÂäüÈîÄÊØÅ", e.message);
//         assert.include(
//           e.message,
//           "is not of the expected type",
//           "‰∏çÊòØÊúüÊúõÁöÑË¥¶Êà∑Á±ªÂûã‰∫Ü"
//         );
//       }

//       try {
//         await fetchAsset(umi, hero1.publicKey.toBase58(), {
//           skipDerivePlugins: false,
//         });
//         // assert.isNull(hero1AccountInfo, "Ëã±ÈõÑ1Â∫îËØ•Â∑≤Ë¢´ÈîÄÊØÅ");
//         assert.fail("Ëã±ÈõÑÂ∫îËØ•Â∑≤Ë¢´ÈîÄÊØÅ");
//       } catch (e: any) {
//         // console.log("‚úÖ Ëã±ÈõÑ2Â∑≤ÊàêÂäüÈîÄÊØÅ", e.message);
//         assert.include(
//           e.message,
//           "is not of the expected type",
//           "‰∏çÊòØÊúüÊúõÁöÑË¥¶Êà∑Á±ªÂûã‰∫Ü"
//         );
//       }

//       // 4. Á≠âÂæÖVRFÈöèÊú∫Êï∞ÁîüÊàê - wait for the VRF random number to be generated
//       await vrfFullFilled(newHero.publicKey);

//       // 5. Êè≠Á§∫Êñ∞Ëã±ÈõÑ - reveal the new hero
//       await program.methods
//         .reveal()
//         .accounts({
//           minter: testUser.publicKey,
//           hero: newHero.publicKey,
//           treasury: vrfTestHelper.treasuryAccount.publicKey,
//         })
//         .signers([testUser, newHero])
//         .rpc();

//       // 6. È™åËØÅÊè≠Á§∫ÂêéÁöÑÈì∏ÈÄ†Áä∂ÊÄÅ - verify the mint state after reveal
//       heroMintState = await program.account.heroMintState.fetch(
//         heroMintStateAddress
//       );
//       assert.equal(heroMintState.minted, true, "Êè≠Á§∫ÂêéÈì∏ÈÄ†Áä∂ÊÄÅÂ∫î‰∏∫true");
//       assert.isAtLeast(heroMintState.result, 0, "Ëã±ÈõÑÁ¥¢ÂºïÂ∫îËØ•Â§ß‰∫éÁ≠â‰∫é0");
//       assert.isBelow(heroMintState.result, 108, "Ëã±ÈõÑÁ¥¢ÂºïÂ∫îËØ•Â∞è‰∫é108");

//       assert.equal(
//         heroMintState.minter.toString(),
//         testUser.publicKey.toString(),
//         "Èì∏ÈÄ†ËÄÖ‰∏çÂåπÈÖç"
//       );

//       // 6.1 È™åËØÅÊè≠Á§∫ÁªìÊûú - verify the reveal result
//       assert.notDeepEqual(
//         heroMintState.randomness,
//         new Array(64).fill(0),
//         "ÈöèÊú∫Êï∞Â∫îËØ•Â∑≤ËÆæÁΩÆ"
//       );

//       // 6.2 È™åËØÅÊè≠Á§∫ÈöèÊú∫Êï∞ÊòØÂê¶Á¨¶ÂêàËã±ÈõÑÁ¥¢Âºï - verify the reveal result
//       let cal_hero_index = calHeroIndex(heroMintState.randomness);
//       assert.equal(
//         heroMintState.result,
//         cal_hero_index,
//         "ËÆ°ÁÆóÁöÑËã±ÈõÑÁ¥¢Âºï‰∏éÈì∏ÈÄ†Áä∂ÊÄÅ‰∏≠Ëã±ÈõÑÁ¥¢Âºï‰∏çÁ¨¶"
//       );

//       // 7. ÊµãËØïËæπÁïåÊÉÖÂÜµÔºöÂ∞ùËØïÂêàÊàêÁõ∏ÂêåÁöÑËã±ÈõÑ
//       const sameHero = await mintAndRevealHero(testUser);
//       const sameNewHero = Keypair.generate();
//       try {
//         await program.methods
//           .combine(sameNewHero.publicKey)
//           .accounts({
//             minter: testUser.publicKey,
//             hero1: sameHero.publicKey,
//             hero2: sameHero.publicKey,
//             treasury: vrfTestHelper.treasuryAccount.publicKey,
//           })
//           .signers([testUser])
//           .rpc();
//         assert.fail("ÂêàÊàêÁõ∏ÂêåÁöÑËã±ÈõÑÂ∫îËØ•Â§±Ë¥•");
//       } catch (error: any) {
//         console.log("‚úÖ È¢ÑÊúüÁöÑÈîôËØØ:", error.message);
//         assert.include(
//           error.message,
//           "SameHeroNotAllowed",
//           "Â∫îËØ•ËøîÂõûSameHeroNotAllowedÈîôËØØ"
//         );
//       }

//       // 7.1 ÊµãËØï‰ΩøÁî®Â∑≤ÈîÄÊØÅÁöÑËã±ÈõÑÂêàÊàê - test using a burned hero to combine
//       const anotherHero = await mintHeroIndexed(testUser, 4);

//       try {
//         await program.methods
//           .combine(newHero.publicKey)
//           .accounts({
//             minter: testUser.publicKey,
//             treasury: vrfTestHelper.treasuryAccount.publicKey,
//             hero1: hero1.publicKey, // Â∑≤ÈîÄÊØÅÁöÑËã±ÈõÑ - burned hero
//             hero2: anotherHero.publicKey,
//           })
//           .signers([testUser])
//           .rpc();
//         assert.fail("‰ΩøÁî®Â∑≤ÈîÄÊØÅÁöÑËã±ÈõÑÂêàÊàêÂ∫îËØ•Â§±Ë¥•");
//       } catch (error: any) {
//         assert.include(
//           error.message,
//           "Failed to serialize or deserialize account data: Unknown",
//           "Â∫îËØ•ËøîÂõûFailed to serialize or deserialize account data: UnknownÈîôËØØ"
//         );
//       }

//       // 8. ÊµãËØïËæπÁïåÊÉÖÂÜµÔºö‰ΩøÁî®Èõ∂Âú∞ÂùÄ‰Ωú‰∏∫ÁßçÂ≠ê - test using zero address as seed
//       const zeroHero1 = await mintAndRevealHero(testUser);
//       const zeroHero2 = await mintAndRevealHero(testUser);
//       try {
//         await program.methods
//           .combine(PublicKey.default)
//           .accounts({
//             minter: testUser.publicKey,
//             hero1: zeroHero1.publicKey,
//             hero2: zeroHero2.publicKey,
//             treasury: vrfTestHelper.treasuryAccount.publicKey,
//           })
//           .signers([testUser])
//           .rpc();
//         assert.fail("‰ΩøÁî®Èõ∂Âú∞ÂùÄ‰Ωú‰∏∫ÁßçÂ≠êÂ∫îËØ•Â§±Ë¥•");
//       } catch (error: any) {
//         console.log("‚úÖ È¢ÑÊúüÁöÑÈîôËØØ:", error.message);
//         assert.include(
//           error.message,
//           "VrfSeedIllegal",
//           "Â∫îËØ•ËøîÂõûVrfSeedIllegalÈîôËØØ"
//         );
//       }

//       // 9. ÊµãËØïËæπÁïåÊÉÖÂÜµÔºöÈîôËØØÁöÑÁî®Êà∑Â∞ùËØïÂêàÊàê - test the wrong user try to combine
//       const wrongHero1 = await mintAndRevealHero(testUser);
//       const wrongHero2 = await mintAndRevealHero(wrongCombineUser);
//       const wrongNewHero = Keypair.generate();

//       try {
//         await program.methods
//           .combine(wrongNewHero.publicKey)
//           .accounts({
//             minter: wrongCombineUser.publicKey,
//             hero1: wrongHero1.publicKey,
//             hero2: wrongHero2.publicKey,
//             treasury: vrfTestHelper.treasuryAccount.publicKey,
//           })
//           .signers([wrongCombineUser])
//           .rpc();
//         assert.fail("ÈîôËØØÁöÑÁî®Êà∑Â∞ùËØïÂêàÊàêÂ∫îËØ•Â§±Ë¥•");
//       } catch (error: any) {
//         console.log("‚úÖ È¢ÑÊúüÁöÑÈîôËØØ:", error.message);
//         assert.include(
//           error.message,
//           "InvalidHeroOwner",
//           "Â∫îËØ•ËøîÂõûInvalidHeroOwnerÈîôËØØ"
//         );
//       }
//     },
//     1000 * 60 * 2 // 2ÂàÜÈíüË∂ÖÊó∂
//   );

//   it("6. Ê≤°Êî∂ÈõÜÈΩêÂÖ®È¢ÜÂ•ñÊµãËØï - not completed collect then claim test", async () => {
//     // 1. Ê≤°ÊúâÊî∂ÈõÜÈΩêÂÖ®È¢ÜÂèñÂ•ñÂä± - claim without collect all
//     log(chalk.green(`ÊµãËØïÊ≤°ÊúâÊî∂ÈõÜÈΩêÔºåÈ¢ÜÂèñÂ•ñÂä±`));

//     // 2. Ëé∑Âèñ testUser Êî∂ËóèÈõÜÂú∞ÂùÄ - get the user collection address
//     const [testUserColAddres] = PublicKey.findProgramAddressSync(
//       [USER_COLLECTION_SEED, testUser.publicKey.toBuffer()],
//       program.programId
//     );

//     // 2.1 Ëé∑ÂèñÊî∂ËóèÈõÜ‰ø°ÊÅØ - get the user collection info
//     let userCollection = await program.account.userCollection
//       .fetch(testUserColAddres)
//       .catch(() => null);

//     // 2.2 Â¶ÇÊûúÊ≤°ÊúâÊî∂ËóèÈõÜÔºåÂàôÊî∂Ëóè‰∏ÄÁÇπÂÑø - if no collection, collect some
//     if (!userCollection) {
//       const hero0 = await mintHeroIndexed(testUser, 0);
//       await collectHero(testUser, hero0.publicKey);
//     }

//     const currentShuihu = await program.account.shuiHu.fetch(shuihuAddress);
//     const currentRound = currentShuihu.round;

//     // 2. ËÆ°ÁÆóÈ¢ÜÂèñÂú∞ÂùÄ - calculate the claim address
//     const [roundClaimAddress] = PublicKey.findProgramAddressSync(
//       [ROUND_CLAIM_SEED, Buffer.from([currentRound])],
//       program.programId
//     );

//     // 2.1 È¢ÜÂèñÂ•ñÂä± - claim reward
//     try {
//       const claimTx = await program.methods
//         .claim()
//         .accounts({
//           minter: testUser.publicKey,
//           roundClaim: roundClaimAddress,
//         })
//         .signers([testUser])
//         .rpc();
//       assert.fail("Êú™Êî∂ÈõÜÂÖ®ÈÉ®Ëã±ÈõÑÁöÑÁî®Êà∑Â∫îËØ•Êó†Ê≥ïÈ¢ÜÂèñÂ•ñÂä±");
//     } catch (error: any) {
//       console.log(`‚úÖ È¢ÑÊúüÁöÑÈîôËØØ: ${error.message}`);
//       assert.include(
//         error.message,
//         "CollectNotCompleted",
//         "Â∫îËØ•ËøîÂõûCollectNotCompletedÈîôËØØ"
//       );
//     }
//   });

//   it(
//     "7.ÁøªËΩÆÈ¢ÜÂ•ñÊµãËØï - claim bonus several round-",
//     async () => {
//       // 1.1. ËÆ°ÁÆó testUser Êî∂ËóèÂÜåÂú∞ÂùÄ
//       const [testUserCollectionAddress] = PublicKey.findProgramAddressSync(
//         [USER_COLLECTION_SEED, testUser.publicKey.toBuffer()],
//         program.programId
//       );

//       // 1.2 ËÆ°ÁÆó testUser ÁöÑ‰ª£Â∏ÅË¥¶Êà∑Âú∞ÂùÄ
//       const testUserTokenAcc = getAssociatedTokenAddressSync(
//         tokenMintAddress,
//         testUser.publicKey,
//         false,
//         TOKEN_2022_PROGRAM_ID
//       );

//       // ÊµãËØï ‰∏âËΩÆÈ¢ÜÂèñÂ•ñÂä±
//       for (let round = 1; round <= 4; round++) {
//         log(chalk.bgBlue(`üî¢ ÂºÄÂßãÁ¨¨ ${round} ËΩÆÊµãËØï`));
//         log(`üî® test User ÂºÄÂßãÈì∏ÈÄ†Âπ∂Êî∂ÈõÜÊâÄÊúâËã±ÈõÑ...`);

//         // 1. Ëé∑ÂèñÂΩìÂâçÁî®Êà∑Êî∂ÈõÜÁä∂ÊÄÅ - get the user collect state
//         let userCollection = await program.account.userCollection
//           .fetch(testUserCollectionAddress)
//           .catch(() => null);

//         // 1.2 Ëé∑ÂèñÂΩìÂâçÁî®Êà∑ÁöÑtoken‰ΩôÈ¢ù - get the user token balance
//         const tokenAccountBefore =
//           await provider.connection.getTokenAccountBalance(testUserTokenAcc);
//         let tokenBalanceBefore = tokenAccountBefore.value.amount || 0;
//         console.log(`üí∞ Èì∏ÈÄ†ÂâçÁî®Êà∑ÂÖÉÂÆù‰ΩôÈ¢ù: ${tokenBalanceBefore}`);
//         log("- tokenAccountBefore", tokenAccountBefore);
//         // 1.3 Èì∏ÈÄ†Âπ∂Êè≠Á§∫‰∏Ä‰∏™Ëã±ÈõÑ - mint and reveal a hero
//         console.log(`üî® Âú®Á¨¨ ${round} ËΩÆÈì∏ÈÄ†Ëã±ÈõÑ...`);
//         const hero = await mintAndRevealHero(testUser);
//         console.log(`‚úÖ Ëã±ÈõÑÈì∏ÈÄ†Âπ∂Êè≠Á§∫ÂÆåÊàê: ${hero.publicKey.toString()}`);

//         // 1.4 Èì∏ÈÄ†Âêé
//         let tokenAccountAfter =
//           await provider.connection.getTokenAccountBalance(testUserTokenAcc);
//         let tokenBalanceAfter = tokenAccountAfter.value.amount || 0;
//         console.log(`üí∞ Èì∏ÈÄ†ÂêéÁî®Êà∑ÂÖÉÂÆù‰ΩôÈ¢ù: ${tokenBalanceAfter}`);

//         // 1.5 Èì∏ÈÄ†ÂêéÈ™åËØÅ - verify after mint
//         let tokenChange =
//           Number(tokenBalanceAfter) - Number(tokenBalanceBefore);

//         // 2. Êî∂ËóèÈΩê - collect all
//         await collectAllHeroForAUser(testUser, "ÊµãËØï test User");
//         // 1.1. Ëé∑ÂèñÂΩìÂâçËΩÆÊ¨°ÂíåÈì∏ÈÄ†‰ª∑Ê†º - get the current round and mint price
//         const currentShuihu = await program.account.shuiHu.fetch(shuihuAddress);
//         const currentRound = currentShuihu.round;
//         const currentMintPrice = currentShuihu.mintPrice.toNumber();
//         const currentBonus = currentShuihu.bonus.toNumber();
//         assert.equal(
//           currentMintPrice,
//           tokenChange,
//           "ÂÖÉÂÆùÂèòÂä®‰∏çÁ¨¶ÂêàËΩÆÊï∞ÔºåÈì∏ÈÄ†‰ª∑Ê†º"
//         );
//         // 2.1 testUser Ë¥¶Êà∑sol‰ΩôÈ¢ù
//         const testUserBalanceBeforeClaim = await provider.connection.getBalance(
//           testUser.publicKey
//         );
//         const teamBalanceBeforeClaim = await provider.connection.getBalance(
//           team
//         );

//         // 2.2. ËÆ°ÁÆóËΩÆÊ¨°È¢ÜÂèñË¥¶Êà∑Âú∞ÂùÄ - calculate the claim address
//         const [roundClaimAddress] = PublicKey.findProgramAddressSync(
//           [ROUND_CLAIM_SEED, Buffer.from([currentRound])],
//           program.programId
//         );

//         const expectedClaimBonus = currentBonus / 2;
//         const expectedTeamBonus = expectedClaimBonus * 0.01;
//         const expectedMinterBonus = expectedClaimBonus - expectedTeamBonus;

//         group(chalk.bgGreen(`üíé ÂºÄÂßãÈ¢ÜÂèñÁ¨¨ ${currentRound} ËΩÆÂ•ñÂä±...`));
//         log(
//           `üèÜ ÂΩìÂâçÂ•ñÊ±†ÈáëÈ¢ù: ${
//             currentBonus / LAMPORTS_PER_SOL
//           } SOL -- ${currentBonus} lamports`
//         );
//         log(
//           `ÂΩìÂâçÈì∏ÈÄ†‰ª∑Ê†º: ${
//             currentMintPrice / LAMPORTS_PER_SOL
//           } SOL -- ${currentMintPrice} lamports`
//         );
//         log(
//           `È¢ÑÊúüÂèëÂá∫ÁöÑÊÄªÂ•ñÂä±: ${
//             expectedClaimBonus / LAMPORTS_PER_SOL
//           } SOL -- ${expectedClaimBonus} lamports`
//         );
//         log(
//           `È¢ÑÊúüÁî®Êà∑Â•ñÂä± ${
//             expectedMinterBonus / LAMPORTS_PER_SOL
//           } SOL -- ${expectedMinterBonus} lamports`
//         );
//         log(
//           `È¢ÑÊúüÂõ¢ÈòüÂ•ñÂä± ${
//             expectedTeamBonus / LAMPORTS_PER_SOL
//           } SOL -- ${expectedTeamBonus} lamports`
//         );
//         log(
//           `test User sol ‰ΩôÈ¢ùÔºö${
//             testUserBalanceBeforeClaim / LAMPORTS_PER_SOL
//           } SOL -- ${testUserBalanceBeforeClaim} lamports`
//         );

//         log(
//           `teamË¥¶Êà∑‰ΩôÈ¢ù: ${
//             teamBalanceBeforeClaim / LAMPORTS_PER_SOL
//           } SOL -- ${teamBalanceBeforeClaim} lamports`
//         );
//         groupEnd();

//         // 3. È¢ÜÂèñÂ•ñÂä± - claim bonus
//         try {
//           const normal_claimTx = await program.methods
//             .claim()
//             .accounts({
//               minter: testUser.publicKey,
//               roundClaim: roundClaimAddress,
//             })
//             .signers([testUser])
//             .rpc({ skipPreflight: true });

//           log(`‚úÖ È¢ÜÂèñÂ•ñÂä±‰∫§ÊòìÂÆåÊàê: ${normal_claimTx}`);
//         } catch (error: any) {
//           console.error(`‚ùå È¢ÜÂèñÂ•ñÂä±Â§±Ë¥•: ${error}`);
//           assert.fail(`È¢ÜÂèñÂ•ñÂä±Â∫îËØ•ÊàêÂäü: ${error.message}`);
//         }

//         // 4. È¢ÜÂèñÂêéÈ™å - verify after claim
//         // 4.1 shuihu Ë¥¶Êà∑
//         const shuihuAfter = await program.account.shuiHu.fetch(shuihuAddress);
//         const bonusAfter = shuihuAfter.bonus.toNumber();
//         const mintPriceAfter = shuihuAfter.mintPrice.toNumber();
//         console.log(
//           `üèÜ Â•ñÊ±†Ââ©‰ΩôÈáëÈ¢ù: ${
//             bonusAfter / LAMPORTS_PER_SOL
//           } SOL, ${bonusAfter} Lamports`
//         );
//         assert.strictEqual(
//           expectedClaimBonus,
//           currentBonus - bonusAfter,
//           "Â•ñÊ±†ÂáèÂ∞ëÈáëÈ¢ùÁ≠â‰∫éÈ¢ÑÊúüÂèëÂá∫ÁöÑÊÄªÂ•ñÈáë"
//         );

//         // 4.2. È™åËØÅËΩÆÊ¨°Â¢ûÂä† - verify round increase
//         assert.equal(shuihuAfter.round, currentRound + 1, "ËΩÆÊ¨°Â∫îËØ•Â¢ûÂä†");
//         // 4.3. È™åËØÅÈì∏ÈÄ†Ë¥πÁî®ÁøªÂÄç - verify mint price double
//         const expectedMintPrice = currentMintPrice * 2;
//         const expectedCalMintPrice =
//           START_MINT_PRICE * 2 ** (shuihuAfter.round - 1);
//         assert.equal(mintPriceAfter, expectedMintPrice, "Èì∏ÈÄ†‰ª∑Ê†ºÂ∫îËØ•ÁøªÂÄç");
//         assert.equal(
//           mintPriceAfter,
//           expectedCalMintPrice,
//           "Èì∏ÈÄ†‰ª∑Ê†ºÂ∫îËØ•‰∏∫È¢ÑÊúüËÆ°ÁÆóÂÄº"
//         );
//         log(chalk.bgGreen("‚úÖ shuihuÈ™åËØÅÈÄöËøá"));

//         // 4.4 È™åËØÅËΩÆÊ¨°È¢ÜÂèñË¥¶Êà∑ - verify round claim account pda
//         const roundClaim = await program.account.roundClaim.fetch(
//           roundClaimAddress
//         );

//         assert.equal(
//           testUser.publicKey.toString(),
//           roundClaim.minter.toString(),
//           "È¢ÜÂèñËÄÖÂåπÈÖç"
//         );
//         assert.equal(currentRound, roundClaim.round, "ËΩÆÊ¨°ÂåπÈÖç");

//         assert.equal(
//           expectedMinterBonus,
//           roundClaim.claimedAmount.toNumber(),
//           "Â•ñÂä±ÈáëÈ¢ùÂåπÈÖç"
//         );
//         log(chalk.bgGreen("‚úÖ ËΩÆÊ¨°È¢ÜÂèñË¥¶Êà∑È™åËØÅÈÄöËøá"));

//         // 4.5. È™åËØÅtestUser ‰ΩôÈ¢ù - verify testUser balance
//         const testUserBalanceAfterClaim = await provider.connection.getBalance(
//           testUser.publicKey
//         );

//         let calTestUserBalanceChange =
//           testUserBalanceAfterClaim - testUserBalanceBeforeClaim;

//         log(
//           `test user Ë¥¶Êà∑ÂèòÂåñÈáëÈ¢ù ${
//             calTestUserBalanceChange / LAMPORTS_PER_SOL
//           } SOL -- ${calTestUserBalanceChange} lamports`
//         );
//         log(
//           `È¢ÑÊúüË¥¶Êà∑ÂèòÂåñÈáëÈ¢ù ${
//             expectedMinterBonus / LAMPORTS_PER_SOL
//           } SOL -- ${expectedMinterBonus} lamports`
//         );
//         assert.approximately(
//           calTestUserBalanceChange / LAMPORTS_PER_SOL,
//           expectedMinterBonus / LAMPORTS_PER_SOL,
//           0.01,
//           "Áî®Êà∑‰ΩôÈ¢ùÂèòÂåñÂ∫îÂú®È¢ÑÊúüÂ•ñÂä±ÁöÑ0.01 SOLËØØÂ∑ÆËåÉÂõ¥ÂÜÖ"
//         );

//         // 4.6 È™åËØÅteamË¥¶Êà∑‰ΩôÈ¢ù - verify team account balance
//         const teamBalanceAfterClaim = await provider.connection.getBalance(
//           team
//         );
//         log(
//           `teamË¥¶Êà∑ÂèòÂåñÈáëÈ¢ù ${
//             teamBalanceAfterClaim - teamBalanceBeforeClaim / LAMPORTS_PER_SOL
//           } SOL -- ${teamBalanceAfterClaim - teamBalanceBeforeClaim} lamports`
//         );
//         log(
//           `È¢ÑÊúüË¥¶Êà∑ÂèòÂåñÈáëÈ¢ù ${
//             expectedTeamBonus / LAMPORTS_PER_SOL
//           } SOL -- ${expectedTeamBonus} lamports`
//         );

//         assert.approximately(
//           (teamBalanceAfterClaim - teamBalanceBeforeClaim) / LAMPORTS_PER_SOL,
//           expectedTeamBonus / LAMPORTS_PER_SOL,
//           0.01,
//           "Âõ¢Èòü‰ΩôÈ¢ùÂèòÂåñÂ∫îÂú®È¢ÑÊúüÂ•ñÂä±ÁöÑ0.01 SOLËØØÂ∑ÆËåÉÂõ¥ÂÜÖ"
//         );

//         // 4.7. È™åËØÅÁî®Êà∑Ëã±ÈõÑÈõÜÂêàÂ∑≤ÈáçÁΩÆ - verify user collection is reset
//         userCollection = await program.account.userCollection.fetch(
//           testUserCollectionAddress
//         );
//         const allReset = userCollection.collection.every((item) => item === 0);
//         assert.isTrue(allReset, "Áî®Êà∑Ëã±ÈõÑÈõÜÂêàÂ∫îËØ•Â∑≤ÈáçÁΩÆ");
//         log(chalk.bgGreen("üîÑ Áî®Êà∑Ëã±ÈõÑÈõÜÂêàÂ∑≤ÈáçÁΩÆÔºåÂèØ‰ª•ÂºÄÂßãÊñ∞‰∏ÄËΩÆÊî∂ÈõÜ"));

//         // 5. ÊµãËØïÈáçÂ§çÈ¢ÜÂèñÂ∫îËØ•Â§±Ë¥• - test duplicate claim should fail
//         try {
//           log(`üîÑ ÊµãËØïÈáçÂ§çÈ¢ÜÂèñÂêå‰∏ÄËΩÆÂ•ñÂä±...`);
//           await program.methods
//             .claim()
//             .accounts({
//               minter: testUser.publicKey,
//               roundClaim: roundClaimAddress,
//             })
//             .signers([testUser])
//             .rpc();
//           assert.fail("ÈáçÂ§çÈ¢ÜÂèñÂêå‰∏ÄËΩÆÂ•ñÂä±Â∫îËØ•Â§±Ë¥•");
//         } catch (error: any) {
//           console.log(`‚úÖ È¢ÑÊúüÁöÑÈîôËØØ: ${error.message}`);
//           assert.include(
//             error.message,
//             "ConstraintSeeds",
//             "Â∫îËØ•ËøîÂõûConstraintSeedsÈîôËØØ"
//           );
//         }
//       }
//     },
//     1000 * 60 * 10 // 10ÂàÜÈíüË∂ÖÊó∂
//   );

//   it(
//     "8.È¢ÜÂèñÊµãËØï2[‰∏§‰∏™Áî®Êà∑ÂêåÊó∂È¢ÜÂèñÊÉÖÂÜµ]- claim test 2 - two users claim at the same time",
//     async () => {
//       // 2. ‰∏∫‰∏§‰∏™Áî®Êà∑Èì∏ÈÄ†Âπ∂Êî∂ÈõÜËã±ÈõÑ - mint and collect all heroes for two users
//       await collectAllHeroForAUser(claimer1, "ÊµãËØï claimer1");
//       await collectAllHeroForAUser(claimer2, "ÊµãËØï claimer2");

//       // 3. Ëé∑ÂèñÂΩìÂâçËΩÆÊ¨° - get the current round
//       const shuihuCurent = await program.account.shuiHu.fetch(shuihuAddress);
//       const currentRound = shuihuCurent.round;
//       const currentBonus = shuihuCurent.bonus.toNumber();
//       const currentMintPrice = shuihuCurent.mintPrice.toNumber();
//       log(
//         `üìä ÂΩìÂâçËΩÆÊ¨°: ${currentRound}, Â•ñÊ±†: ${
//           currentBonus / LAMPORTS_PER_SOL
//         } SOL - ${currentBonus} lamports`
//       );

//       // 3.1 ËÆ∞ÂΩï‰∏§‰∏™Ë¥¶Êà∑ÂàùÂßãÂÄº - record the initial balances for both users
//       const claimer1_balance_before = await provider.connection.getBalance(
//         claimer1.publicKey
//       );
//       const claimer2_balance_before = await provider.connection.getBalance(
//         claimer2.publicKey
//       );
//       const teamBalanceBeforeClaim = await provider.connection.getBalance(team);
//       log(`claimer1 ‰ΩôÈ¢ù ${claimer1_balance_before / LAMPORTS_PER_SOL} SOL`);
//       log(`claimer2 ‰ΩôÈ¢ù ${claimer2_balance_before / LAMPORTS_PER_SOL} SOL`);

//       // 3.2 ËÆ°ÁÆóÈ¢ÑÊúüÂ•ñÂä± - calculate the expected rewards
//       const expectedClaimBonus = currentBonus / 2;
//       const expectedTeamBonus = expectedClaimBonus * 0.01;
//       const expectedMinterBonus = expectedClaimBonus - expectedTeamBonus;
//       log(
//         `È¢ÑÊúüÁî®Êà∑Â•ñÂä± ${
//           expectedMinterBonus / LAMPORTS_PER_SOL
//         } SOL - ${expectedMinterBonus} lamports`
//       );
//       log(
//         `È¢ÑÊúüÂõ¢ÈòüÂ•ñÂä± ${
//           expectedTeamBonus / LAMPORTS_PER_SOL
//         } SOL - ${expectedTeamBonus} lamports`
//       );

//       // 4. ‰∏§‰∏™Áî®Êà∑ÂêåÊó∂È¢ÜÂèñ - claim both users at the same time
//       // 4.1 ËÆ°ÁÆóÈ¢ÜÂèñÂ•ñÂä±PDAÂú∞ÂùÄ - calculate the claim address
//       const [roundClaimAddress] = PublicKey.findProgramAddressSync(
//         [ROUND_CLAIM_SEED, Buffer.from([currentRound])],
//         program.programId
//       );

//       // 4.2 ‰∏§‰∏™Áî®Êà∑ÂêåÊó∂È¢ÜÂèñ - claim both users at the same time
//       const [claimTx1, claimTx2] = await Promise.all([
//         program.methods
//           .claim()
//           .accounts({
//             minter: claimer1.publicKey,
//             roundClaim: roundClaimAddress,
//           })
//           .signers([claimer1])
//           .rpc({ skipPreflight: true })
//           .catch((e) => {
//             log(`‚ùå  claimer 1 È¢ÜÂèñÂ§±Ë¥•`, e.message);
//             return null;
//           }),
//         program.methods
//           .claim()
//           .accounts({
//             minter: claimer2.publicKey,
//             roundClaim: roundClaimAddress,
//           })
//           .signers([claimer2])
//           .rpc({ skipPreflight: true })
//           .catch((e) => {
//             log(`‚ùå  claimer 2 È¢ÜÂèñÂ§±Ë¥•`, e.message);
//             return null;
//           }),
//       ]);

//       console.log("- claim Tx 1", claimTx1);
//       console.log("- claim Tx 2", claimTx2);

//       // 4.3 È™åËØÅ‰∏§‰∏™Áî®Êà∑È¢ÜÂèñÊàêÂäü - verify both users claim successfully
//       const successCount = [claimTx1, claimTx2].filter(
//         (tx) => tx !== null
//       ).length;
//       console.log(`‚úÖ ÊàêÂäüÈ¢ÜÂèñÊ¨°Êï∞: ${successCount}`);
//       assert.equal(successCount, 1, "Â∫îËØ•Âè™Êúâ‰∏Ä‰∏™Áî®Êà∑ÊàêÂäüÈ¢ÜÂèñÂ•ñÂä±");

//       const claimer1_balance_after = await provider.connection.getBalance(
//         claimer1.publicKey
//       );
//       const claimer2_balance_after = await provider.connection.getBalance(
//         claimer2.publicKey
//       );

//       // 4.4 ËÆ°ÁÆó‰ΩôÈ¢ùÂèòÂåñ - calculate the balance change
//       const claimer1_balance_change =
//         claimer1_balance_after - claimer1_balance_before;
//       const claimer2_balance_change =
//         claimer2_balance_after - claimer2_balance_before;
//       log(
//         `claimer1 ‰ΩôÈ¢ùÂèòÂåñ ${
//           claimer1_balance_change / LAMPORTS_PER_SOL
//         } SOL - ${claimer1_balance_change} lamports`
//       );
//       log(
//         `claimer2 ‰ΩôÈ¢ùÂèòÂåñ ${
//           claimer2_balance_change / LAMPORTS_PER_SOL
//         } SOL - ${claimer2_balance_change} lamports`
//       );

//       // 4.5 È™åËØÅÂè™Êúâ‰∏Ä‰∏™Áî®Êà∑Ëé∑Âæó‰∫ÜÂ•ñÂä± - verify only one user gets the reward
//       const totalChange = claimer1_balance_change + claimer2_balance_change;
//       // ËÄÉËôëÂà∞gasË¥πÁî®ÂíåÂàõÂª∫PDAÁöÑÁßüÈáëÔºå‰ΩøÁî®approximatelyÊñ≠Ë®Ä
//       assert.approximately(
//         Math.abs(totalChange) / LAMPORTS_PER_SOL,
//         expectedMinterBonus / LAMPORTS_PER_SOL,
//         0.1,
//         "ÊÄªÂ•ñÂä±ÈáëÈ¢ùÂ∫îËØ•Êé•ËøëÈ¢ÑÊúüÂÄº"
//       );

//       log(chalk.bgGreen("‚úÖ claimer È™åËØÅÈÄöËøá"));

//       const shuihuAfter = await program.account.shuiHu.fetch(shuihuAddress);
//       const bonusAfter = shuihuAfter.bonus.toNumber();
//       const mintPriceAfter = shuihuAfter.mintPrice.toNumber();

//       console.log(
//         `üèÜ Â•ñÊ±†Ââ©‰ΩôÈáëÈ¢ù: ${
//           bonusAfter / LAMPORTS_PER_SOL
//         } SOL, ${bonusAfter} Lamports`
//       );
//       assert.strictEqual(
//         currentBonus - bonusAfter,
//         expectedClaimBonus,
//         "Â•ñÊ±†ÂáèÂ∞ëÈáëÈ¢ùÁ≠â‰∫éÈ¢ÑÊúüÂèëÂá∫ÁöÑÊÄªÂ•ñÈáë"
//       );

//       assert.equal(shuihuAfter.round, currentRound + 1, "ËΩÆÊ¨°Â∫îËØ•Â¢ûÂä†");
//       const expectedMintPrice = currentMintPrice * 2;
//       const expectedCalMintPrice =
//         START_MINT_PRICE * 2 ** (shuihuAfter.round - 1);
//       assert.equal(mintPriceAfter, expectedMintPrice, "Èì∏ÈÄ†‰ª∑Ê†ºÂ∫îËØ•ÁøªÂÄç");
//       assert.equal(
//         mintPriceAfter,
//         expectedCalMintPrice,
//         "Èì∏ÈÄ†‰ª∑Ê†ºÂ∫îËØ•‰∏∫È¢ÑÊúüËÆ°ÁÆóÂÄº"
//       );
//       log(chalk.bgGreen("‚úÖ shuihuÈ™åËØÅÈÄöËøá"));

//       // 4.7 È™åËØÅroundClaimË¥¶Êà∑ - verify round claim account
//       const roundClaim = await program.account.roundClaim.fetch(
//         roundClaimAddress
//       );

//       if (claimTx1) {
//         assert.equal(
//           claimer1.publicKey.toString(),
//           roundClaim.minter.toString(),
//           "È¢ÜÂèñËÄÖÂåπÈÖç"
//         );
//       }

//       if (claimTx2) {
//         assert.equal(
//           claimer2.publicKey.toString(),
//           roundClaim.minter.toString(),
//           "È¢ÜÂèñËÄÖÂåπÈÖç"
//         );
//       }

//       assert.equal(currentRound, roundClaim.round, "ËΩÆÊ¨°ÂåπÈÖç");

//       assert.equal(
//         expectedMinterBonus,
//         roundClaim.claimedAmount.toNumber(),
//         "Â•ñÂä±ÈáëÈ¢ùÂåπÈÖç"
//       );
//       log(chalk.bgGreen("‚úÖ ËΩÆÊ¨°È¢ÜÂèñË¥¶Êà∑È™åËØÅÈÄöËøá"));

//       // 4.6 È™åËØÅteamË¥¶Êà∑‰ΩôÈ¢ù - verify team account balance
//       const teamBalanceAfterClaim = await provider.connection.getBalance(team);
//       log(
//         `teamË¥¶Êà∑ÂèòÂåñÈáëÈ¢ù ${
//           teamBalanceAfterClaim - teamBalanceBeforeClaim / LAMPORTS_PER_SOL
//         } SOL -- ${teamBalanceAfterClaim - teamBalanceBeforeClaim} lamports`
//       );
//       log(
//         `È¢ÑÊúüË¥¶Êà∑ÂèòÂåñÈáëÈ¢ù ${
//           expectedTeamBonus / LAMPORTS_PER_SOL
//         } SOL -- ${expectedTeamBonus} lamports`
//       );

//       assert.approximately(
//         (teamBalanceAfterClaim - teamBalanceBeforeClaim) / LAMPORTS_PER_SOL,
//         expectedTeamBonus / LAMPORTS_PER_SOL,
//         0.01,
//         "Âõ¢Èòü‰ΩôÈ¢ùÂèòÂåñÂ∫îÂú®È¢ÑÊúüÂ•ñÂä±ÁöÑ0.01 SOLËØØÂ∑ÆËåÉÂõ¥ÂÜÖ"
//       );
//     },
//     60 * 1000 * 10
//   );
// });

// function calHeroIndex(randomness: number[]): number {
//   // 1. Â∞ÜÂâç8‰∏™Â≠óËäÇËΩ¨Êç¢‰∏∫64‰ΩçÊï¥Êï∞
//   const buffer = Buffer.from(randomness.slice(0, 8));
//   const revealed_random_value_u64 = buffer.readBigUInt64LE();
//   // 2. ËÆ°ÁÆóÊ¶ÇÁéáÊÄªÂíå
//   let total_probability = 0;
//   hero_list.forEach((hero:any) => {
//     total_probability += hero.probability;
//   });
//   // 3. ËÆ°ÁÆó‰ΩôÊï∞
//   const remainder = revealed_random_value_u64 % BigInt(total_probability);
//   // 4. Êü•ÊâæÂØπÂ∫îÁöÑËã±ÈõÑÁ¥¢Âºï
//   let cumulative_probability = BigInt(0);
//   const hero_index = hero_list.findIndex((info: any) => {
//     cumulative_probability += BigInt(info.probability);
//     return cumulative_probability > remainder;
//   });
//   return hero_index;
// }
